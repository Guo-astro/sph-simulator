/**
 * @file kernel_function_test.cpp
 * @brief BDD tests for template-based kernel functions
 */

#include "../bdd_helpers.hpp"
#include "../../include/core/cubic_spline.hpp"
#include "../../include/core/wendland_kernel.hpp"
#include <cmath>

using namespace sph;
using namespace sph::Spline;
using namespace sph::Wendland;

// ============================================================
// Cubic Spline Kernel Tests
// ============================================================

TEST(CubicSplineKernel, NormalizationConstants_AreCorrect) {
    EXPECT_NEAR(sigma_cubic<1>(), 2.0 / 3.0, 1e-10);
    EXPECT_NEAR(sigma_cubic<2>(), 10.0 / (7.0 * M_PI), 1e-10);
    EXPECT_NEAR(sigma_cubic<3>(), 1.0 / M_PI, 1e-10);
}

TEST(CubicSplineKernel, PowerOfH_1D) {
    real h = 2.0;
    EXPECT_EQ(sph::powh<1>(h), 2.0);
}

TEST(CubicSplineKernel, PowerOfH_2D) {
    real h = 2.0;
    EXPECT_EQ(sph::powh<2>(h), 4.0);
}

TEST(CubicSplineKernel, PowerOfH_3D) {
    real h = 3.0;
    EXPECT_EQ(sph::powh<3>(h), 27.0);
}

TEST(CubicSplineKernel, 1D_KernelValue_AtZero) {
    Cubic1D kernel;
    real h = 1.0;
    real w_zero = kernel.w(0.0, h);
    
    // Kernel should be maximum at r=0
    EXPECT_GT(w_zero, 0.0);
}

TEST(CubicSplineKernel, 1D_KernelValue_Decreases) {
    Cubic1D kernel;
    real h = 1.0;
    
    real w0 = kernel.w(0.0, h);
    real w1 = kernel.w(0.5 * h, h);
    real w2 = kernel.w(1.0 * h, h);
    
    // Kernel should decrease with distance
    EXPECT_GT(w0, w1);
    EXPECT_GT(w1, w2);
}

TEST(CubicSplineKernel, 2D_KernelValue_AtZero) {
    Cubic2D kernel;
    real h = 1.0;
    real w_zero = kernel.w(0.0, h);
    
    EXPECT_GT(w_zero, 0.0);
}

TEST(CubicSplineKernel, 2D_Gradient_AtZeroDistance) {
    Cubic2D kernel;
    real h = 1.0;
    Vector2D rij(0.0, 0.0);
    
    auto grad = kernel.dw(rij, 0.0, h);
    
    // Gradient should be zero when r=0
    EXPECT_EQ(grad[0], 0.0);
    EXPECT_EQ(grad[1], 0.0);
}

TEST(CubicSplineKernel, 2D_Gradient_PointsAwayFromOrigin) {
    Cubic2D kernel;
    real h = 1.0;
    Vector2D rij(0.5, 0.0);
    real r = abs(rij);
    
    auto grad = kernel.dw(rij, r, h);
    
    // Gradient should point in same direction as rij
    EXPECT_NE(grad[0], 0.0);
    // For attractive kernels in SPH, gradient typically has same sign as rij[0]
}

TEST(CubicSplineKernel, 3D_Construction) {
    Cubic3D kernel;
    // Should construct without errors
    EXPECT_EQ(Cubic3D::dimension(), 3);
}

TEST(CubicSplineKernel, 3D_KernelValue) {
    Cubic3D kernel;
    real h = 1.0;
    real r = 0.5;
    
    real w_val = kernel.w(r, h);
    EXPECT_GT(w_val, 0.0);
}

TEST(CubicSplineKernel, 3D_Gradient) {
    Cubic3D kernel;
    real h = 1.0;
    Vector3D rij(0.3, 0.4, 0.0);
    real r = abs(rij);  // r = 0.5
    
    auto grad = kernel.dw(rij, r, h);
    
    // Gradient should be finite
    EXPECT_TRUE(std::isfinite(grad[0]));
    EXPECT_TRUE(std::isfinite(grad[1]));
    EXPECT_TRUE(std::isfinite(grad[2]));
}

TEST(CubicSplineKernel, DerivativeWRTh_IsFinite) {
    Cubic2D kernel;
    real h = 1.0;
    real r = 0.5;
    
    real dhw_val = kernel.dhw(r, h);
    EXPECT_TRUE(std::isfinite(dhw_val));
}

// ============================================================
// Wendland C4 Kernel Tests
// ============================================================

TEST(WendlandKernel, NormalizationConstants_AreCorrect) {
    EXPECT_EQ(sigma_c4<1>(), 0.0);  // Not defined for 1D
    EXPECT_NEAR(sigma_c4<2>(), 9.0 / M_PI, 1e-10);
    EXPECT_NEAR(sigma_c4<3>(), 495.0 / (32.0 * M_PI), 1e-10);
}

// Note: Cannot test 1D construction due to static_assert at compile time
// TEST(WendlandKernel, 1D_ThrowsException) is not possible with static_assert

TEST(WendlandKernel, 2D_Construction) {
    C4Kernel2D kernel;
    EXPECT_EQ(C4Kernel2D::dimension(), 2);
}

TEST(WendlandKernel, 2D_KernelValue_AtZero) {
    C4Kernel2D kernel;
    real h = 1.0;
    real w_zero = kernel.w(0.0, h);
    
    EXPECT_GT(w_zero, 0.0);
}

TEST(WendlandKernel, 2D_KernelValue_Decreases) {
    C4Kernel2D kernel;
    real h = 1.0;
    
    real w0 = kernel.w(0.0, h);
    real w1 = kernel.w(0.5 * h, h);
    
    EXPECT_GT(w0, w1);
}

TEST(WendlandKernel, 2D_Gradient) {
    C4Kernel2D kernel;
    real h = 1.0;
    Vector2D rij(0.5, 0.0);
    real r = abs(rij);
    
    auto grad = kernel.dw(rij, r, h);
    
    EXPECT_TRUE(std::isfinite(grad[0]));
    EXPECT_TRUE(std::isfinite(grad[1]));
}

TEST(WendlandKernel, 3D_Construction) {
    C4Kernel3D kernel;
    EXPECT_EQ(C4Kernel3D::dimension(), 3);
}

TEST(WendlandKernel, 3D_KernelValue) {
    C4Kernel3D kernel;
    real h = 1.0;
    real r = 0.3;
    
    real w_val = kernel.w(r, h);
    EXPECT_GT(w_val, 0.0);
}

TEST(WendlandKernel, 3D_Gradient) {
    C4Kernel3D kernel;
    real h = 1.0;
    Vector3D rij(0.1, 0.2, 0.2);
    real r = abs(rij);  // r = 0.3
    
    auto grad = kernel.dw(rij, r, h);
    
    EXPECT_TRUE(std::isfinite(grad[0]));
    EXPECT_TRUE(std::isfinite(grad[1]));
    EXPECT_TRUE(std::isfinite(grad[2]));
}

TEST(WendlandKernel, DerivativeWRTh_IsFinite) {
    C4Kernel2D kernel;
    real h = 1.0;
    real r = 0.5;
    
    real dhw_val = kernel.dhw(r, h);
    EXPECT_TRUE(std::isfinite(dhw_val));
}

// ============================================================
// Kernel Comparison Tests
// ============================================================

TEST(KernelComparison, BothKernels_PositiveAtOrigin_2D) {
    Cubic2D cubic;
    C4Kernel2D wendland;
    real h = 1.0;
    
    real w_cubic = cubic.w(0.0, h);
    real w_wendland = wendland.w(0.0, h);
    
    EXPECT_GT(w_cubic, 0.0);
    EXPECT_GT(w_wendland, 0.0);
}

TEST(KernelComparison, BothKernels_DecreaseWithDistance_2D) {
    Cubic2D cubic;
    C4Kernel2D wendland;
    real h = 1.0;
    
    real r1 = 0.2;
    real r2 = 0.5;
    
    EXPECT_GT(cubic.w(r1, h), cubic.w(r2, h));
    EXPECT_GT(wendland.w(r1, h), wendland.w(r2, h));
}

// ============================================================
// Compile-Time Dimension Tests
// ============================================================

TEST(KernelDimension, Cubic_HasCorrectDimension) {
    EXPECT_EQ(Cubic1D::dimension(), 1);
    EXPECT_EQ(Cubic2D::dimension(), 2);
    EXPECT_EQ(Cubic3D::dimension(), 3);
}

TEST(KernelDimension, Wendland_HasCorrectDimension) {
    EXPECT_EQ(C4Kernel2D::dimension(), 2);
    EXPECT_EQ(C4Kernel3D::dimension(), 3);
}
